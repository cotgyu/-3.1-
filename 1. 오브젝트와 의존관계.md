# 1. 오브젝트와 의존관계
스프링 프레임워크에서 가장 중요한 것은 **오브젝트**(생성, 다른 오브젝트와의 관계, 사용, 소멸)이라 설명하면서, 스프링은 오브젝트를 어떻게 효과적으로 설계하고 구현, 사용 , 어떻게 개선해야하는 가의 기준을 마련해준다고 한다.
> 객체지향 기술, 설계, 구현, 검증된 프렉티스를 프레임워크로 제공

<br>

어떠한 변경이 일어날 때, 필요한 작업을 최소화하고 다른 곳에 영향이 가지 않게 하는 것이 중요한데, 이를 **분리와 확장을 고려한 설계**라 한다. 이 분리의 개념 중 하나인 **관심사의 분리**를 책에서 단계별 예제를 통해 소개하고 있다.
~~~text
관심사의 분리 - 관심이 같은 것은 하나의 객체 안으로, 관심이 다른 것은 가능한 떨어뜨려 서로 영향이 가지 않게 분리
~~~

<br>

책에서는 간단한 사용자를 등록하는 UserDao를 제시하였는데, 여기에는 3가지 관심사가 있다.
  1. DB연결을 위한 커넥션
  2. SQL을 실행하는 statement
  3. statement, 커넥션 닫기

1장에서는 1번을 분리와 확장을 고려하여 개선하는 작업을 수행하였다.

**첫번째**로 이 커넥션 부분을 getConnention 이라는 함수로 빼내었고, 이를 통해 분리하였다. (**메소드 추출 기법**)

**두번째**로는 커넥션 확장을 위해 상속을 사용하였다. UserDao를 상속하고 서브클래스에서 추상메소드인 getConnention을 구현하여 DB커넥션 연결이라는 관심을 서브클래스로 분리하여 각자 원하는 구성의 getConnention을 사용하는 소개하고있다.
~~~text
템플릿 메소드 패턴 - 슈퍼클래스의 기본적인 로직흐름을 만들고, 그 기능의 일부를 추상메소드나 오버라이딩이 가능한 메소드 등 
으로 만든 뒤 서브클래스에서 필요에 맞게 구현, 사용하는 방법

팩토리 메소드 패턴 - 상속을 통해 기능을 확장하는 패턴으로 서브클래스에서 구체적인 오브젝트 생성방법을 결정한다.
~~~

_하지만 이 상속을 이용한 방법도 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함게 수정하거나 다시 개발할 수 있는 단점이 있음.(생각보다 밀접한 관계)_

그래서 책에서는 **세번째**로 상속이 아닌 인터페이스를 통해 클래스를 분리하는 것을 소개한다. 이를 통해 UserDao는 인터페이스의 메소드를 통해 알 수 있는 기능에만 관심을 가지면 되지, 그 기능을 어떻게 구현했는지에는 관심을 둘 필요가 없어진다.
(최종족으로 UserDao는 ConnentionMaker라는 인터페이스 외에는 어떤 클래스와 관계를 갖지 않게 개선하였다.)

<br>

책에서는 이 UserDao를 개선해온 결과를 **객체지향 기술의 여러가지 이론**을 통해 설명하였다.

~~~text
개방 폐쇄 원칙(OCP) - 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀있어야한다. (객체지향설계원칙)

높은 응집도 - 하나의 모듈이나 클래스가 하나의 책임 또는 관심사에 집중되어 있다.
낮은 응집도 - 하나의 오브젝트가 변경이 발생할 때, 관계를 맺고있는 다른 오브젝트에 변경을 최소화한다.

전략패턴 - 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 
클래스를 팔요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴  
ex) DB연결방식(ConnentionMaker) - 알고리즘
~~~

 >스프링은 이러한 객체지향적 설계원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크라고 소개하고 있다.

<br>

책에서는 어떤 ConnectioNmaker를 사용할지 결정하는 기능을 UserDaoTest가 맡고 있는데, 이를 분리하면서 **팩토리**의 개념을 설명하고 있다. 
<br>
(DaoFactory를 통해 UserDao타입의 오브젝트를 어떻게 만들고, 어떻게 준비하는지를 결정하도록 개선하였다.)
~~~text
팩토리 - 객체의 생성방법을 결정하고 만들어진 오브젝트를 돌려줌.
~~~

<br>

이를 통해 책에서는 기존의 Dao는 모든 종류의 작업을 사용하는 쪽에서 제어하는 반면, 개선된 Dao는 ConnectionMaker의 구현 클래스 결정과 오브젝트의 생성의 제어권이 DaoFactory에 있음을 비교하며 **IoC**를 설명하고 있다.

~~~text
 IoC(제어의 역전) - 객체에 대한 제어권이 개발자로 부터 컨테이너에 넘어가면서 객체의 생성부터 생명주기 관리까지의 
 모든 것을 컨테이너가 맡아서 함
~~~

>스프링은 IoC를 극적으로 적용하고 있는 프레임워크

<br>

스프링의 **IoC**
~~~text
빈(bean): 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
(스프링 빈 - 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트)

빈 팩토리: 빈의 생성과 관계설정 같은 제어를 담당하는 IoC오브젝트
(어플리케이션 컨텍스트 - 별도의 정보를 참고해 빈의 생성, 관계 설정 등 제어작업 총괄)

어노테이션
@Configuration - 스프링이 오브젝트 설정을 담당하는 클래스로 인식
(어플리케이션 컨텍스트가 사용할 설정 정보)
@bean: 오브젝트 생성 담당

Application Context: 어플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당
- 오브젝트 팩토리가 아무리 많아도 이를 알아야하거나 직접 사용X
- 종합 IoC서비스를 제공한다.
- 빈을 검색하는 다양한 방법을 제공한다. (이름, 타입, 어노테이션)
~~~

<br>

책에서는 DaoFactory와 어플리케이션컨텍스트를 사용해서 UserDao를 호출 시 차이점을 보여주면서 **싱글톤**을 설명하고 있다.
~~~text
DaoFactory를 직접 사용해서 UserDao를 여러번 호출 시 다른 오브젝트가 생성되지만, 애플리케이션 컨텍스트를 이용하면 
동일한 오브젝트가 생성되는 것을 볼 수 있는데(싱글톤 레지스트리),
이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이라고 설명하고 있다.
(서버 환경에서는 싱글토의 사용이 권장됨)

또한 자바의 기본 싱글톤 패턴 구현은 여러 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 관리하는 기능을 제공한다.

스프링 빈 스코프: 빈이 생성되고 존재하고, 적용되는 범위
 - 기본은 싱글톤(컨테이너 내 한개, 컨테이너가 존재하는 한 유지)
 - 그 외 프로토 타입, 요청, 세션 등 있음(10장에서 자세한 설명)
~~~

<br>

IoC의 대표적인 동작원리 -  **DI**
~~~text
DI(의존관계 주입)
- 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘겨 자신은 수동적으로 주입받은 오브젝트를 사용
- 어떤 오브젝트가 이용할 오브젝트를 프로퍼티에 설정
- 객체의 실체를 외부환경설정(xml, 어노테이션 등)에서 컨트롤 할 수 있도록 하는 것
~~~

>DI(의존관계 주입)를 통해 모듈간 결합도를 낮춰서 유연한 변경이 가능해진다.

<br>

스프링은 DaoFactory와 같은 자바클래스 외에도 다양한 방법들을 통해 DI의존관계 설정 정보를 만들 수 있는데, 책에서는 대표적으로 XML을 이용한 설정을 소개하고 있다.
~~~text
장점
- XML은 텍스트파일이기 때문에 다루기 쉽다.
- 쉽게 이해 할 수 있다.
- 컴파일과 같은 별도의 빌드 작업이 필요 없다.
- 스키마나 DTD를 이용해 정해진 포멧에 따라 작성되었는지 확인 가능하다.

@Configuration -> <beans>
@bean -> <bean>
~~~


>  스프링이란 '어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크' 라는 사실을 기억하자. <br>
스프링의 관심은 오브젝트와 그 관계다.
